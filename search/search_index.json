{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About SilverLite FS-i6 firmware is a firmware replacement for the FlySky-i6 transmitter (and not the FlySky FS-i6S or the FlySky FS-i6X). This custom firmware was designed for my particular use case: controlling 65mm/75mm whoops and micro (100mm) sized quadcopters. The features that are available along with the user interface are therefore rather limited. It does just what I need and not much more. This firmware is primarily designed to interface with flight controllers running Silverware or variations of that software: BWhoop Silverware , SilF4ware , NFE Silverware , NFE Silverware with SilverLite extensions (a fork I made but haven't released), and SilverLite . All of these Silveware based flight controllers provide support for a Bayang protocol. This is the protocol that SilverLite FS-i6 is primarily based upon. However this requires a hardware modification to the FlySky-i6 so that an NRF24L01 transceiver module be installed. The internal A7105 transceiver module is left alone and intact, but the firmware simply ignores it. In addition to the Bayang protocol, SilverFlite FS-i6 can also work with a multiprotocol module connected via serial (trainer port on back of the i6). This restores the FlySky protocol as well as introduces the huge variety of additional protocols provided by Pascal's module . Note: I'd like to someday re-enable support for the internal A7105 module (FlySky protocol) but have not had the time to do so. And since I already have a multiprotocol module installed I'm not really inclined to do this anytime soon.","title":"Introduction"},{"location":"#about","text":"SilverLite FS-i6 firmware is a firmware replacement for the FlySky-i6 transmitter (and not the FlySky FS-i6S or the FlySky FS-i6X). This custom firmware was designed for my particular use case: controlling 65mm/75mm whoops and micro (100mm) sized quadcopters. The features that are available along with the user interface are therefore rather limited. It does just what I need and not much more. This firmware is primarily designed to interface with flight controllers running Silverware or variations of that software: BWhoop Silverware , SilF4ware , NFE Silverware , NFE Silverware with SilverLite extensions (a fork I made but haven't released), and SilverLite . All of these Silveware based flight controllers provide support for a Bayang protocol. This is the protocol that SilverLite FS-i6 is primarily based upon. However this requires a hardware modification to the FlySky-i6 so that an NRF24L01 transceiver module be installed. The internal A7105 transceiver module is left alone and intact, but the firmware simply ignores it. In addition to the Bayang protocol, SilverFlite FS-i6 can also work with a multiprotocol module connected via serial (trainer port on back of the i6). This restores the FlySky protocol as well as introduces the huge variety of additional protocols provided by Pascal's module . Note: I'd like to someday re-enable support for the internal A7105 module (FlySky protocol) but have not had the time to do so. And since I already have a multiprotocol module installed I'm not really inclined to do this anytime soon.","title":"About"},{"location":"Acknowledgements/","text":"Background The first two commits of this repo were obtained by forking the F6-i6 Test repo by Nathan Tsoi. This provided me a test bed for building a bare bones .elf that I could flash onto my FS-i6 transmitter. While it may not do anything except blink the backlight on the LCD display screen, it was a huge help providing me the necessary drivers, header files, etc that one needs for targetting a microcontroller that I was completely unfamiliar with. Another huge resource was the FlySkyI6 repo from Jakub (qba667). And of course I must also mention this repo: https://github.com/benb0jangles/FlySky-i6-Mod- from Ben (Benbojangles) I also came across some great information shared by Thom . Some of the early work investigating the FS-i6 likely stems from here. A big brother to the FlySky FS-i6 is the FS-i6s as well as the Turnigy Evolution. Both of these use an stm32 chip instead of the Kinetis found on the FS-i6. For these transmitters you really must take a look at the amazing breadth of information shared by Simon Schulz (fishpepper) and particularly his OpenGround project . These are just some of the resources I came across that I found so helpful. I know that there are many more contributors (to understanding the FS-i6) that I am either unaware of, or unable to identify and provide credit to. For example there are hundreds of pages of discussion on rcgroups.com regarding custom firmware patches for the FS-i6. A careful review of all of those posts would probably help identify other great contributors to this effort. To all of those that I mentioned, as well as those I'm unaware of: \"Thank you very much\". Your sharing of knowledge adds so much to our community of builders, hackers and hobbyists! Open Source Software I was able to reference or even use some really helpful open source code to help with my development. Some of it was previously mentioned but I want to spend some time to list some other sources I found to be useful. GEM (Good enough menu) system. See: https://github.com/Spirik/GEM JeeH by Jean-Claude Wippler. See: https://platformio.org/lib/show/3082/JeeH and https://git.jeelabs.org/jcw/jeeh DIY Multiprotocol TX Module. See: https://github.com/pascallanger/DIY-Multiprotocol-TX-Module nRF24L01 multi-protocol RC transmitter. See: https://github.com/goebish/nrf24_multipro","title":"Acknowledgements"},{"location":"Acknowledgements/#background","text":"The first two commits of this repo were obtained by forking the F6-i6 Test repo by Nathan Tsoi. This provided me a test bed for building a bare bones .elf that I could flash onto my FS-i6 transmitter. While it may not do anything except blink the backlight on the LCD display screen, it was a huge help providing me the necessary drivers, header files, etc that one needs for targetting a microcontroller that I was completely unfamiliar with. Another huge resource was the FlySkyI6 repo from Jakub (qba667). And of course I must also mention this repo: https://github.com/benb0jangles/FlySky-i6-Mod- from Ben (Benbojangles) I also came across some great information shared by Thom . Some of the early work investigating the FS-i6 likely stems from here. A big brother to the FlySky FS-i6 is the FS-i6s as well as the Turnigy Evolution. Both of these use an stm32 chip instead of the Kinetis found on the FS-i6. For these transmitters you really must take a look at the amazing breadth of information shared by Simon Schulz (fishpepper) and particularly his OpenGround project . These are just some of the resources I came across that I found so helpful. I know that there are many more contributors (to understanding the FS-i6) that I am either unaware of, or unable to identify and provide credit to. For example there are hundreds of pages of discussion on rcgroups.com regarding custom firmware patches for the FS-i6. A careful review of all of those posts would probably help identify other great contributors to this effort. To all of those that I mentioned, as well as those I'm unaware of: \"Thank you very much\". Your sharing of knowledge adds so much to our community of builders, hackers and hobbyists!","title":"Background"},{"location":"Acknowledgements/#open-source-software","text":"I was able to reference or even use some really helpful open source code to help with my development. Some of it was previously mentioned but I want to spend some time to list some other sources I found to be useful. GEM (Good enough menu) system. See: https://github.com/Spirik/GEM JeeH by Jean-Claude Wippler. See: https://platformio.org/lib/show/3082/JeeH and https://git.jeelabs.org/jcw/jeeh DIY Multiprotocol TX Module. See: https://github.com/pascallanger/DIY-Multiprotocol-TX-Module nRF24L01 multi-protocol RC transmitter. See: https://github.com/goebish/nrf24_multipro","title":"Open Source Software"},{"location":"Flashing/","text":"Flashing the firmware Precompiled images are available on the releases page on github. Three file formats ( .bin , .elf , .hex ) are provided; choose whichever one works best with the flashing software/tool you have available. Hardware adapters An ST-Link v2 or a J-Link adapter will be needed. Many ST-Link v2 clones are readily available on Ebay and Amazon. Unless you have a J-Link adapter already or intend to debug with more than 2 breakpoints, purchasing an ST-Link adapter is the cheapest and simplest hardware solution. The adapter will connect to the SWD (Serial Wire Debug) interface pins on the mainboard. Only three pins need connecting: SWDIO - Serial Wire Data I/O. Labeled \"SWD-DIO\" on the mainboard. SWCLK - Serial Wire Clock. Labeled \"SWD-CLK\" on the mainboard GND - Ground wire. Labeled \"GND\" on the mainboard. A really good writeup (with pictures) on the FlySky FS-i6 can be found on Nathan Tsoi's blog . Here is a picture he took of the SWD interface port. You'll use three \"breadboard jumper wires\" or sometimes called \"Dupont\" wires with female to female ends. Attach them to the pins labeled \"SWCLK\", \"SWDIO\", \"GND\" as shown in this picture: These pins are inline and adjacent to one another and are the top three pins on the rightmost column of pins when viewing from the pin side of the adapter with the notch of the housing towards the left. Connect these wires to their corresponding pins on the i6 mainboard. OpenOCD Please refer to the \"Setting up your development environment\" document and look for the \"Installing OpenOCD on Windows\" or \"Installing OpenOCD on Mac OS\" sections for details on installing OpenOCD. Flash using OpenOCD with ST-Link adapter Ensure your ST-Link adapter is wired to your i6 as described earlier. Plug your ST-Link adapter to an available USB port on your computer. Then power up the i6 transmitter. You'll use the fs-i6.elf version of the firmware file. Open a terminal or command prompt window and navigate to the folder that you downloaded (or copied) the fs-i6.elf file into. Then enter this command: openocd -f interface/stlink.cfg -f target/klx.cfg -c program fs-i6.elf verify reset exit Note: Details about the OpenOCD program command can be found here: http://openocd.org/doc/html/Flash-Programming.html Flash using JLink Please refer to the JLink software documentation for how to flash. I actually use my JLink adapter quite often but I do this using a \"Build Task\" that I configured Visual Studio to use. More details about this can be found in the \"Setting up your development environment\" section. Hint: I use a JLink \"CommanderScript\" that might be of help. The \"Build Task\" in Visual Studio basically does this: JLink -CommanderScript ../.vscode/load-release.jlink You can review that load-release.jlink file for the parameters actually being used with the JLink tool.","title":"Flashing"},{"location":"Flashing/#flashing-the-firmware","text":"Precompiled images are available on the releases page on github. Three file formats ( .bin , .elf , .hex ) are provided; choose whichever one works best with the flashing software/tool you have available.","title":"Flashing the firmware"},{"location":"Flashing/#hardware-adapters","text":"An ST-Link v2 or a J-Link adapter will be needed. Many ST-Link v2 clones are readily available on Ebay and Amazon. Unless you have a J-Link adapter already or intend to debug with more than 2 breakpoints, purchasing an ST-Link adapter is the cheapest and simplest hardware solution. The adapter will connect to the SWD (Serial Wire Debug) interface pins on the mainboard. Only three pins need connecting: SWDIO - Serial Wire Data I/O. Labeled \"SWD-DIO\" on the mainboard. SWCLK - Serial Wire Clock. Labeled \"SWD-CLK\" on the mainboard GND - Ground wire. Labeled \"GND\" on the mainboard. A really good writeup (with pictures) on the FlySky FS-i6 can be found on Nathan Tsoi's blog . Here is a picture he took of the SWD interface port. You'll use three \"breadboard jumper wires\" or sometimes called \"Dupont\" wires with female to female ends. Attach them to the pins labeled \"SWCLK\", \"SWDIO\", \"GND\" as shown in this picture: These pins are inline and adjacent to one another and are the top three pins on the rightmost column of pins when viewing from the pin side of the adapter with the notch of the housing towards the left. Connect these wires to their corresponding pins on the i6 mainboard.","title":"Hardware adapters"},{"location":"Flashing/#openocd","text":"Please refer to the \"Setting up your development environment\" document and look for the \"Installing OpenOCD on Windows\" or \"Installing OpenOCD on Mac OS\" sections for details on installing OpenOCD.","title":"OpenOCD"},{"location":"Flashing/#flash-using-openocd-with-st-link-adapter","text":"Ensure your ST-Link adapter is wired to your i6 as described earlier. Plug your ST-Link adapter to an available USB port on your computer. Then power up the i6 transmitter. You'll use the fs-i6.elf version of the firmware file. Open a terminal or command prompt window and navigate to the folder that you downloaded (or copied) the fs-i6.elf file into. Then enter this command: openocd -f interface/stlink.cfg -f target/klx.cfg -c program fs-i6.elf verify reset exit Note: Details about the OpenOCD program command can be found here: http://openocd.org/doc/html/Flash-Programming.html","title":"Flash using OpenOCD with ST-Link adapter"},{"location":"Flashing/#flash-using-jlink","text":"Please refer to the JLink software documentation for how to flash. I actually use my JLink adapter quite often but I do this using a \"Build Task\" that I configured Visual Studio to use. More details about this can be found in the \"Setting up your development environment\" section. Hint: I use a JLink \"CommanderScript\" that might be of help. The \"Build Task\" in Visual Studio basically does this: JLink -CommanderScript ../.vscode/load-release.jlink You can review that load-release.jlink file for the parameters actually being used with the JLink tool.","title":"Flash using JLink"},{"location":"Manual/","text":"On power up When you turn on the TX it will load the last model that you used and enter \"use\" mode. If your quad is already powered up and configured for auto-bind the LCD display will resemble the following: The menu display in \"Use\" mode is very simple consisting primarily of a large countdown timer, signal strength numbers and battery voltages. The name of the selected model is displayed on the bottom status bar. While the top status bar has a speaker icon on the left to indicate if sounds (beeps) are enabled or not. The TX battery voltage is displayed on the right of the top status bar. Exit to main menu When in \"Use\" mode you can press the \"Cancel\" button to exit to the main menu. An alert dialog will prompt you to press the \"OK\" button to exit to the main menu. Or you can press \"Cancel\" button to dismiss the alert dialog and return to \"Use\" mode. Safe start When entering \"Use\" mode (whether from powerup or from main menu), if the SwA or SwD switches are \"Up\", or the throttle stick is not fully down, the TX will not arm and an \"Alert\" dialog is displayed instead. Flip the switches up and/or push the throttle stick all the way down to exit the \"Alert\" dialog and enter \"Use\" mode. Alternatively you can long press the \"Cancel\" button to exit the \"Alert\" dialog and enter the main menu. The Main Menu The main menu is where you can edit models and select one to use. You can also use this menu to configure and review the sticks and aux channels. You use the push buttons on the FlySky to navigate the menu: Ok - Used to confirm or activate a selection Cancel - Used to cancel an operation or back up out of a menu level Up - Used to move up in a menu list Down - Used to move down in a menu list Yaw Trim - This button can be pushed to the left to back out of some menu options, or to the right to activate certain menu options. It can also be used to decrement or increment a value in the menu (such as a letter field or a number field). And it can also be used to move left/right within a multi character (or digit) field. Select model At the top of the main menu screen will be displayed the currently selected model name. Use the up/down buttons to hilite the \"Select model\" option and then press the \"OK\" button or you can push the \"Yaw Trim\" button towards the right to activate the option. The menu will then list the available models. Use the up/down buttons to hilite your selection. If you go past the last entry the menu will advance to the next page of models. There are a total of 10 models. Use the \"OK button to activate your selection. Or use the \"Cancel\" button to back out of the menu. Or you can hilite the first item in the list (which is a left arrowhead) and press \"OK\" to back out of this menu. Edit model As mentioned previously, the name of the currently selected model is displayed at the top of the main menu. To edit this model select and activate the \"Edit current model\" option. This will the \"Edit model\" submenu. This has two screens that will let you edit various properties of the model. The first page has the menu options: Name Model names are limited to 9 characters in length. Upper case and lower case letters are allowed: a..z , A..Z . Numbers 0..9 are allowed. And the space, hyphen and underscore characters: , - , _ . Seconds: This is the number of seconds used for the flight countdown timer. Protocol: Here you can choose either the internal (NRF24L01) Bayang protocol, or one of the Multiprotocol Module protocols that were enabled when SilverLite was built. Subprotocol: The available options are based on which \"Protocol\" was selected For \"Internal\" protocol the options are: Stock - This is a stock Bayang protocol (2ms period) Silverware - This is a Bayang protocol for Silverware flight controllers (3ms period or 5ms if telemetry enabled). Note: SilverLite extensions are available if \"Options\" is set to 7 LT8900 - This is like the \"Silverware\" subprotocol and should only be used if the flight controller is using an LT8900 transceiver instead of an NRF24L01 or XN297/XN297L transceiver. All other Subprotocol options are dependent on the chosen Multiprotcol \"Protocol\" The second page of the \"Edit model\" menu has these options: Option: When \"Internal\" is used for \"Protocol\" then this is a number that can enable certain features. Add the numbers below to combine several features. 0 - No additional features 1 - Enable telemetry 2 - Analog aux channels ( VrA and VrB ) will be used for P and D term tuning (\"Subprotocol\" must be set to \"Silverware\"). 4 - Enable SilverLite extensions if flight controller firmware supports SilverLite (\"Subprotocol\" must be set to \"Silverware\"). Auto-bind: This is used by the external Multiprotocol Module RX Num: This is used by the external Multiprotocol Module Use model The third option on the main menu is \"Use model\". Select and activate this option to begin using the currently selected model. Calibrate Sticks The fourth option on the main menu is \"Calibrate Sticks\". Select and activate this option to calibrate the gimbals through their entire range of motion. Follow the directions and press \"OK\" to apply changes and exit. Or press \"Cancel\" to discard your changes and exit. Note: Ignore the numbers that are displayed. Just follow the directions View Sliders The fifth option on the main menu is \"View Sliders\". Select and activate this option to view the AETR channels, analog aux channels ( VrA and VrB ) and two analog switches ( SwB and SwC ) as slider bars. Move your sticks, rotate those knobs and flip those switches to see the sliders in action. Bind When in \"Use\" mode you can press the \"BIND KEY\" button to activate bind mode. An alert dialog is displayed asking you to confirm that you really want to bind. Press and hold the \"OK\" button for about a second to confirm and enter a bind mode or press \"Cancel\" button to abort. Note: The bind mode only lasts for a little less than a second. This seems long enough for both Bayang and FlySky receivers. Beeps Yes, I hooked up some beep alerts. But I don't really like them. Tap the \"OK\" button when in \"Use\" mode to toggle them on/off. The top left corner of the LCD screen shows a cheezy speaker icon with sound on/off to indicate whether beeps are enabled or not. If I remember correctly I think they are: Double-beeps during last 15 seconds of flight timer to signal that the timer is close to expiring. More beeps (I forget what they sound like) when quadcopter battery voltage (as reported by telemetry) drops below some hardcoded value in the code","title":"How to use"},{"location":"Manual/#on-power-up","text":"When you turn on the TX it will load the last model that you used and enter \"use\" mode. If your quad is already powered up and configured for auto-bind the LCD display will resemble the following: The menu display in \"Use\" mode is very simple consisting primarily of a large countdown timer, signal strength numbers and battery voltages. The name of the selected model is displayed on the bottom status bar. While the top status bar has a speaker icon on the left to indicate if sounds (beeps) are enabled or not. The TX battery voltage is displayed on the right of the top status bar.","title":"On power up"},{"location":"Manual/#exit-to-main-menu","text":"When in \"Use\" mode you can press the \"Cancel\" button to exit to the main menu. An alert dialog will prompt you to press the \"OK\" button to exit to the main menu. Or you can press \"Cancel\" button to dismiss the alert dialog and return to \"Use\" mode.","title":"Exit to main menu"},{"location":"Manual/#safe-start","text":"When entering \"Use\" mode (whether from powerup or from main menu), if the SwA or SwD switches are \"Up\", or the throttle stick is not fully down, the TX will not arm and an \"Alert\" dialog is displayed instead. Flip the switches up and/or push the throttle stick all the way down to exit the \"Alert\" dialog and enter \"Use\" mode. Alternatively you can long press the \"Cancel\" button to exit the \"Alert\" dialog and enter the main menu.","title":"Safe start"},{"location":"Manual/#the-main-menu","text":"The main menu is where you can edit models and select one to use. You can also use this menu to configure and review the sticks and aux channels. You use the push buttons on the FlySky to navigate the menu: Ok - Used to confirm or activate a selection Cancel - Used to cancel an operation or back up out of a menu level Up - Used to move up in a menu list Down - Used to move down in a menu list Yaw Trim - This button can be pushed to the left to back out of some menu options, or to the right to activate certain menu options. It can also be used to decrement or increment a value in the menu (such as a letter field or a number field). And it can also be used to move left/right within a multi character (or digit) field.","title":"The Main Menu"},{"location":"Manual/#select-model","text":"At the top of the main menu screen will be displayed the currently selected model name. Use the up/down buttons to hilite the \"Select model\" option and then press the \"OK\" button or you can push the \"Yaw Trim\" button towards the right to activate the option. The menu will then list the available models. Use the up/down buttons to hilite your selection. If you go past the last entry the menu will advance to the next page of models. There are a total of 10 models. Use the \"OK button to activate your selection. Or use the \"Cancel\" button to back out of the menu. Or you can hilite the first item in the list (which is a left arrowhead) and press \"OK\" to back out of this menu.","title":"Select model"},{"location":"Manual/#edit-model","text":"As mentioned previously, the name of the currently selected model is displayed at the top of the main menu. To edit this model select and activate the \"Edit current model\" option. This will the \"Edit model\" submenu. This has two screens that will let you edit various properties of the model. The first page has the menu options: Name Model names are limited to 9 characters in length. Upper case and lower case letters are allowed: a..z , A..Z . Numbers 0..9 are allowed. And the space, hyphen and underscore characters: , - , _ . Seconds: This is the number of seconds used for the flight countdown timer. Protocol: Here you can choose either the internal (NRF24L01) Bayang protocol, or one of the Multiprotocol Module protocols that were enabled when SilverLite was built. Subprotocol: The available options are based on which \"Protocol\" was selected For \"Internal\" protocol the options are: Stock - This is a stock Bayang protocol (2ms period) Silverware - This is a Bayang protocol for Silverware flight controllers (3ms period or 5ms if telemetry enabled). Note: SilverLite extensions are available if \"Options\" is set to 7 LT8900 - This is like the \"Silverware\" subprotocol and should only be used if the flight controller is using an LT8900 transceiver instead of an NRF24L01 or XN297/XN297L transceiver. All other Subprotocol options are dependent on the chosen Multiprotcol \"Protocol\" The second page of the \"Edit model\" menu has these options: Option: When \"Internal\" is used for \"Protocol\" then this is a number that can enable certain features. Add the numbers below to combine several features. 0 - No additional features 1 - Enable telemetry 2 - Analog aux channels ( VrA and VrB ) will be used for P and D term tuning (\"Subprotocol\" must be set to \"Silverware\"). 4 - Enable SilverLite extensions if flight controller firmware supports SilverLite (\"Subprotocol\" must be set to \"Silverware\"). Auto-bind: This is used by the external Multiprotocol Module RX Num: This is used by the external Multiprotocol Module","title":"Edit model"},{"location":"Manual/#use-model","text":"The third option on the main menu is \"Use model\". Select and activate this option to begin using the currently selected model.","title":"Use model"},{"location":"Manual/#calibrate-sticks","text":"The fourth option on the main menu is \"Calibrate Sticks\". Select and activate this option to calibrate the gimbals through their entire range of motion. Follow the directions and press \"OK\" to apply changes and exit. Or press \"Cancel\" to discard your changes and exit. Note: Ignore the numbers that are displayed. Just follow the directions","title":"Calibrate Sticks"},{"location":"Manual/#view-sliders","text":"The fifth option on the main menu is \"View Sliders\". Select and activate this option to view the AETR channels, analog aux channels ( VrA and VrB ) and two analog switches ( SwB and SwC ) as slider bars. Move your sticks, rotate those knobs and flip those switches to see the sliders in action.","title":"View Sliders"},{"location":"Manual/#bind","text":"When in \"Use\" mode you can press the \"BIND KEY\" button to activate bind mode. An alert dialog is displayed asking you to confirm that you really want to bind. Press and hold the \"OK\" button for about a second to confirm and enter a bind mode or press \"Cancel\" button to abort. Note: The bind mode only lasts for a little less than a second. This seems long enough for both Bayang and FlySky receivers.","title":"Bind"},{"location":"Manual/#beeps","text":"Yes, I hooked up some beep alerts. But I don't really like them. Tap the \"OK\" button when in \"Use\" mode to toggle them on/off. The top left corner of the LCD screen shows a cheezy speaker icon with sound on/off to indicate whether beeps are enabled or not. If I remember correctly I think they are: Double-beeps during last 15 seconds of flight timer to signal that the timer is close to expiring. More beeps (I forget what they sound like) when quadcopter battery voltage (as reported by telemetry) drops below some hardcoded value in the code","title":"Beeps"},{"location":"Multiprotocol/","text":"This is a placeholder Describe how multiprotocol module is supported via serial (trainer port). Describe how list of available protocols is currently limited due to menu system awkwardness TODO: Mapping of i6 aux channels to multiprotocol channels","title":"Multiprotocol module"},{"location":"Multiprotocol/#this-is-a-placeholder","text":"Describe how multiprotocol module is supported via serial (trainer port). Describe how list of available protocols is currently limited due to menu system awkwardness TODO: Mapping of i6 aux channels to multiprotocol channels","title":"This is a placeholder"},{"location":"TODO/","text":"Use numbers (1..10) for default Model names Reset timer when re-binding Discard stick calibration values if user uses \"Cancel\" button New UI for customizing aux switches/channels to Bayang output New UI for customizing aux switches/channels to Multiprotocol module output","title":"TODO"},{"location":"devEnvSetup/","text":"Setting up your development environment This page will walk you through the steps of setting up your development environment so that you can build and deploy this project onto your FlySky FS-i6 transmitter. For editing, compiling and flashing the firmware you have two choices: Install and use MCUXpresso Integrated Development Environment (IDE) Install the indvidual tools/systems (arm compiler toolchain, make, openocd, vscode, etc) and configure them accordingly. Note: I once had this project set up to also use Keil MDK (free evaluation version) but the code size of this project now exceeds the 32k limit of Keil. The project files are still in the repo and can probably be updated to work (assuming you have an upgraded Keil without the size limit). The easy way Installing and using MCUXpresso is by far the simplest solution. It is \"A free-of-charge, code size unlimited, easy-to-use IDE for Kinetis and LPC MCUs, and i.MX RT crossover MCUs\". Visit the NXP website here to download the latest version. Note: You will need to register with NXP in order to download MCUXpresso. MCUXpresso is based on Eclipse with various plugins preinstalled and customized. The repo contains a .project and a .cproject file that MCUXpresso should be able to open. I'll leave it to you to figure out how to use MCUXpresso. With it you should be able to build (compile) the project, flash the firmware (via ST-Link or J-Link), and even debug the code. The hard way The other choice (installing the discrete tools) is a lot more work but something I feel is worth it. By doing so, it sets up your development computer so that you can develop for many more platforms and hardware devices. The tools/systems you'll be installing will consist of: * A code editor (Visual Studio Code is what I'll suggest and describe here) * A compiler toolchain * make as your build system * OpenOCD. A software tool for flashing firmware via ST-Link adapter It should be possible to develop on Mac OS, Linux and Windows platforms. This is due to using a variety of open source tools and technologies that are supported on all of these operating systems. Note: The specific examples provided here will often be written from the perspective of using a Windows development PC. I hope to update this document in the future to provide more specific examples for Mac OS and Linux platforms. Developing with VSCode I really like Visual Studio Code. It's readily available for Mac OS, Windows and Linux. Plus it's very fast and extensible! I use it not only for editing the code, but also the documentation. And because it has integrated terminal windows I also use it for building and monitoring. It can be an excellent (and lightweight) development envrironment for embedded devices. I've used it with great success when developing for ESP8266, ESP32, Arduino (AVR), STM32, etc. I often use it with Platform IO (but not so with this project). I'll describe how to set up VSCode and associated tools so that we can develop for the (ARM cortex m0+ based) Kinetis KL16 micro used on the FlySky FS-i6 transmitter. Note: Some of what is described here was learned from this (most excellent) article: \"Using Visual Studio Code with STM32CubeMX for ARM Development\" . It's worth the time to read it for yourself. What we'll need Here are the list of software tools we'll need for this project. ARM gnu toolchain mingw-w64 (if you will be developing under Windows) This is needed solely for the make tool, or more specifically mingw32-make.exe OpenOCD Visual Studio Code , and the following extensions: Cortex Debug C/C++ for Visual Studio Code Project Manager Note: I've tried using the STM32 ST-LINK utility as well as the open source version from texane but was not able to establish a connection using the ST-Link V2 debugger/programmer I have. Thankfully I was able to get OpenOCD working. You will also need some hardware in order to connect your development PC to your FlySky FS-i6 transmitter. I'm using a (cheapie clone) ST-Link V2 programmer/debugger purchased from Amazon but also readily available on ebay . While working on a previous development project I had installed the \"ST-Link Utility\" from here: https://www.st.com/en/development-tools/stsw-link004.html I'm pretty sure that's how I ended up getting the st-link drivers installed onto my Windows 10 development machine. I also ended up updating the firmware on my ST-Link V2 probe using that utility but I'm not sure if that was necessary. I'm noting it here in case it may be useful. If you don't already have drivers installed for your ST-Link V2 probe, you may be able to use the drivers provided by the OpenOCD installation (described later). Installing the tools If you don't already have VScode installed on your machine please visit: https://code.visualstudio.com/ Follow the install directions. Afterwards we'll need to install some extensions and also configure VSCode slightly. After installing Visual Studio Code, launch it and navigate to Extensions tab or press Ctrl+Shift+X . Install the following extensions: C/C++ \u2013 https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools Cortex Debug \u2013 https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug Project Manager \u2013 https://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager Press F1 key and type open settings json . Select Open Settings (JSON) . In the opened file, insert the following property at the top of the list and save. cortex-debug.armToolchainPath : ${env:VSARM}\\\\armcc\\\\bin\\\\ , For example my settings.json ends up looking like this: { cortex-debug.armToolchainPath : ${env:VSARM}\\\\armcc\\\\bin\\\\ , terminal.integrated.rendererType : dom , terminal.integrated.shell.windows : C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe , platformio-ide.forceUploadAndMonitor : true } Note: The ${env:VSARM} is refrencing an enviornment variable that we'll create shortly For the remaining tools I recommend installing them into into a single folder. On my Windows machine I use C:\\Tools . You could also choose to use C:\\VSARM . Keep it simple and avoid having spaces in the path. On a Mac or Linux machine you could create a subfolder in your home folder. mkdir ~/vsarm Create an environment variable named VSARM and set its value to this folder. For example on my Mac I added this line to my ~/.zshrc file: # VSARM export VSARM= $HOME/vsarm Note: If you use bash (the default shell for Mac OS) then you would instead add that to your ~/.bash_profile file. Install arm gnu toolchain Go to: https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads Download the appropriate installer. There are several available. Windows installation For my Windows development PC I chose: gcc-arm-none-eabi-8-2019-q3-update-win32-sha2.exe Windows 32-bit Installer (Signed for Windows 7 and later) MD5: d44f44b258b203bdd6808752907754be Run the installer. When it prompts you to \"Choose Install Location\" I changed the default shown in \"Destination Folder\" from: C:\\Program Files (x86)\\GNU Tools ARM Embedded\\8 2019-q3-update to C:\\Tools\\armcc Make sure these gnu tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\armcc\\bin Mac OS installation For my old MacBook I chose to download this version: Mac OS X 64-bit File: gcc-arm-none-eabi-8-2019-q3-update-mac.tar.bz2 (105.72 MB) Using a Finder window I then double-clicked on the downloaded .bz2 file which unpacked the contents into a new folder named: gcc-arm-none-eabi-8-2019-q3-update I then renamed that folder to armcc and then moved this armcc folder into my ~/vsarm folder. Finally I adjusted my path by editing my .zshrc file and added this to the bottom of it: # vsarm tools export PATH= $HOME/vsarm/armcc/bin:$PATH Note: If you use bash for your shell (which is the default for Mac OS) then add the above to your ~/.bash_profile instead. Install MinGW-W64 (for Windows machines only) This step is only needed for Windows development machines. We need MinGW-W64 for the mingw32-make.exe program. If you have already have a make utility on your machine then you could skip this Go to: https://sourceforge.net/projects/mingw-w64/ Change the install location to: C:\\Tools\\mingw Make sure the MinGW-W64 tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\mingw\\mingw32\\bin Installing OpenOCD on Windows For Windows users I recommend obtaining a version of OpenOCD from here: https://gnutoolchains.com/arm-eabi/openocd/ Download the most recent 7zip file: openocd-20190828.7z Decompress it into C:\\Tools folder. Rename the resultant OpenOCD-20190828-0.10.0 folder to just OpenOCD . Make sure the OpenOCD tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\OpenOCD\\bin Note: There are several binary versions of OpenOCD available for installation. The one from SysProgs (gnutoolchains.com) seems to be updated regularly and also provides drivers that may be helpful to you. Installing OpenOCD on Mac OS While it may be possible to install a prebuilt version of OpenOCD using Homebrew, I've learned that the OpenOCD project maintainers recommend Mac/Linux users to build it themselves using the latest version of the source code available from the repository. Note: We will be using the \"Cortex Debug\" extension for VSCode. The README.md file from https://github.com/Marus/cortex-debug mentions not using the default version of OpenOCD provided by Homebrew. So...even more reason for us to build it from source. So to be safe, we'll use Homebrew to build and install OpenOCD using the latest available source code. Using Terminal, enter the following: brew install open-ocd --HEAD This took a little while to complete, but once it finished I found it was immmediately available for use at /usr/local/bin/openocd . No adjustments to my path were needed. Setup Visual Studio Code Project This git repo already contains the necessary configurations we need (see the various files in the .vscode folder). Howver I'm going to document how I created these configs so that future adjustments can be performed (such as adding additional source/include folders, etc). Note: For more detailed information about these configs visit: https://code.visualstudio.com/docs/editor/variables-reference https://code.visualstudio.com/docs/cpp/config-msvc https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference Configure C/CPP From within VSCode press F1 key and type edit config and choose C/CPP: Edit Configurations (JSON) . The default contents of this file will look something like this: { configurations : [ { name : Win32 , includePath : [ ${workspaceFolder}/** ], defines : [ _DEBUG , UNICODE , _UNICODE ], windowsSdkVersion : 10.0.17763.0 , compilerPath : C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/VC/Tools/MSVC/14.16.27023/bin/Hostx64/x64/cl.exe , cStandard : c11 , cppStandard : c++17 , intelliSenseMode : msvc-x64 } ], version : 4 } Replace all of this and enter the following: { configurations : [ { name : Debug , includePath : [ ${env:VSARM}/armcc/arm-none-eabi/include/c++/8.3.1 , ${env:VSARM}/armcc/arm-none-eabi/include/c++/8.3.1/arm-none-eabi , ${env:VSARM}/armcc/arm-none-eabi/include/c++/8.3.1/backward , ${env:VSARM}/armcc/lib/gcc/arm-none-eabi/8.3.1/include , ${env:VSARM}/armcc/lib/gcc/arm-none-eabi/8.3.1/include-fixed , ${env:VSARM}/armcc/arm-none-eabi/include , ${workspaceFolder}/** ], defines : [ DEBUG ], intelliSenseMode : clang-x64 , browse : { path : [ ${workspaceFolder} , ${env:VSARM}/armcc ], limitSymbolsToIncludedHeaders : false, databaseFilename : } } ], version : 4 } Be sure to adjust the arm gnu folders such as: ${env:VSARM}/armcc/arm-none-eabi/include/c++/8.3.1 to match the version you actually have installed (hint: the 8.3.1 might need to be changed). For the \"includePath\" property you could replace the \"${workspaceFolder}/**\" wildcard with actual folders (like: \"${workspaceFolder}/include\" ) if you wish. For the \"defines\" property you should add any entries your project may require (examples: \"SOME_VALUE=0x8000\" , \"USE_SOMETHING\" , etc). To create a \"Release\" configuration you could duplicate the above config, change the \"name\" property to \"Release\" , change the \"DEBUG\" define to \"NDEBUG\" , etc. Configure VSCode Tasks From within VSCode press F1 key and type config task and choose Tasks: Configure tasks . Click on Create tasks.json file from template and select the Other option. The tasks.json file will open. The default contents of this file will look something like this: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format version : 2.0.0 , tasks : [ { label : echo , type : shell , command : echo Hello } ] } Replace the contents of this file with the following: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format version : 2.0.0 , tasks : [ { label : Clean Debug , type : shell , command : make DEBUG=1 clean , windows : { command : mingw32-make.exe DEBUG=1 clean }, options : { cwd : ${workspaceRoot} }, group : build , problemMatcher : [] }, { label : Clean Release , type : shell , command : make DEBUG=0 clean , windows : { command : mingw32-make.exe DEBUG=0 clean }, options : { cwd : ${workspaceRoot} }, group : build , problemMatcher : [] }, { label : Make Debug Firmware , type : shell , command : make -j12 DEBUG=1 , windows : { command : mingw32-make.exe -j12 DEBUG=1 }, options : { cwd : ${workspaceRoot} }, group : build , presentation : { reveal : always , clear : true }, problemMatcher : [] }, { label : Make Release Firmware , type : shell , command : make -j12 DEBUG=0 , windows : { command : mingw32-make.exe -j12 DEBUG=0 }, options : { cwd : ${workspaceRoot} }, group : { kind : build , isDefault : true }, presentation : { reveal : always , clear : true }, problemMatcher : [] }, { label : OpenOCD Flash Debug Firmware , type : shell , command : openocd -f interface/stlink.cfg -f target/klx.cfg -c \\ program fs-i6.elf verify reset exit\\ , options : { cwd : ${workspaceRoot}/gcc_debug }, group : build , problemMatcher : [] }, { label : OpenOCD Flash Release Firmware , type : shell , command : openocd -f interface/stlink.cfg -f target/klx.cfg -c \\ program fs-i6.elf verify reset exit\\ , options : { cwd : ${workspaceRoot}/gcc_release }, group : build , problemMatcher : [] }, { label : JLink Flash Release Firmware , type : shell , windows : { options : { shell : { executable : cmd.exe , args : [ /d , /c ] } }, command : JLink -CommanderScript ../.vscode/load-release.jlink , }, options : { cwd : ${workspaceRoot}/gcc_release , }, group : build , problemMatcher : [] }, { label : JLink Flash Debug Firmware , type : shell , windows : { options : { shell : { executable : cmd.exe , args : [ /d , /c ] } }, command : JLink -CommanderScript ../.vscode/load-release.jlink , }, options : { cwd : ${workspaceRoot}/gcc_debug , }, group : build , problemMatcher : [] } ] } Note: Be sure to adjust the -j parameter to the make if needed. To run any of these tasks you can use Ctrl-Alt-T on Windows, or Ctrl-Option-T on Mac to bring up a menu that allows you to choose any of these tasks we've just defined. Alternatively you can use F1 key and type run task and choose Tasks: Run Task . Configure VSCode shell One very important note: The makefile I'm using uses rm -rf as part of building the clean target. This rm command isn't normally available on windows. So I've configured my VSCode environment to use a bash shell whenever it needs to provide a shell for any command. This bash shell came with my Git for Windows installation. If you have something similar, then you'll want to configure VSCode to use such a shell. Alternatively you can edit the makefile(s) in this project folder. To configure VSCode to use a particular shell you need to edit your settings.json file. Details are provided here: https://code.visualstudio.com/docs/editor/integrated-terminal . Basically you need to enter a configuration line like one of the following: // Command Prompt terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\cmd.exe // PowerShell terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe // Git Bash terminal.integrated.shell.windows : C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe // Bash on Ubuntu (on Windows) terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\bash.exe Obviously you should use one of the bash options in the above examples. Personally I prefer the bash from my git install versus the one from my Windows Subsystem for Linux (WSL) since it loads up much faster. Configure Debugger From within VSCode use F1 key, type launch and select Debug: Open launch.json and choose the Cortex Debug option. The launch.json file will open with contents that should look something like this: { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 version : 0.2.0 , configurations : [ { name : Cortex Debug , cwd : ${workspaceRoot} , executable : ./bin/executable.elf , request : launch , type : cortex-debug , servertype : jlink } ] } Replace it with this: { version : 0.2.0 , configurations : [ { name : Launch Debug config , type : cortex-debug , request : launch , servertype : openocd , cwd : ${workspaceRoot} , executable : ./Debug/i6.elf , device : Kinetis , svdFile : ${workspaceRoot}/.vscode/MKL16Z4.svd , configFiles : [ interface/stlink.cfg , target/klx.cfg , ] }, { name : Attach Debug config , type : cortex-debug , request : attach , servertype : openocd , cwd : ${workspaceRoot} , executable : ./Debug/i6.elf , device : Kinetis , svdFile : ${workspaceRoot}/.vscode/MKL16Z4.svd , configFiles : [ interface/stlink.cfg , target/klx.cfg , ] } ] } Some useful info about these configs can be found here: https://marcelball.ca/projects/cortex-debug/cortex-debug-launch-configurations/ After these additions have been made you can click on the Debug icon on the left of VSCode and be able to execute one of these configurations. Regarding the .svd file in the above config. A Google search for kinetis svd files led me to this: https://github.com/posborne/cmsis-svd/issues/29 which in turn led me to this: https://github.com/hackrid/KDS_SVD/blob/master/KDS_3_2/MKL16Z4.svd . \"semihosting\" It is possible to direct printf messages ( stdout ) to the debug interface. This capability is known as semihosting . Note: I discovered this via Google and reading about this: https://dzone.com/articles/semihosting-gnu-arm-embedded and also https://bgamari.github.io/posts/2014-10-31-semihosting.html I have not yet attempted using this feature but will investigate this soon. Add \"Shortcuts\" extension to VSCode The \"Shortcuts\" extension will install clickable icons on the bottom status bar of VSCode. Each icon is a shortcut to a vscode command. Setting this up was tricky. There's no clear documentation that I could find. Press F1 key and type preferences workspace . Select Preferences: Open Workspace Settings . Enter shortcuts in the search bar. Hover your mouse cursor over \"Shortcuts: Buttons\" and a gear icon will appear. Click on the gear icon and choose \"Copy Setting as JSON\" (this will ), then click on \"Edit in settings.json\". Position the cursor between the curly brackets and then paste ( Ctrl+V / Cmd+V ) the copied setting into the file. The file should look like this: shortcuts.buttons : [ file-binary , workbench.action.tasks.build , Run build task , beaker , workbench.action.tasks.test , Run test task , terminal , workbench.action.terminal.toggleTerminal , Toggle terminal panel , telescope , workbench.action.showCommands , Show command palette , bug, workbench.action.debug.start, Launch debug ] This will create 5 new icons on the bottom status bar. I'd prefer to customize these to just 3. So replace the above contents with the following: shortcuts.buttons : [ file-binary , workbench.action.tasks.build , Run Build Task , rocket , workbench.action.tasks.runTask , Run Task , bug, workbench.action.debug.start, Launch Debug ] The first icon (\"file-binary\") should launch the \"Make Debug Firmware\" task (because that is the only one marked as the default build task). The second icon will execute the \"Tasks: Run Task\" command which reveals a dropdown menu of the available tasks. And the third icon will launch a debugging session.","title":"Setting up your development environment"},{"location":"devEnvSetup/#setting-up-your-development-environment","text":"This page will walk you through the steps of setting up your development environment so that you can build and deploy this project onto your FlySky FS-i6 transmitter. For editing, compiling and flashing the firmware you have two choices: Install and use MCUXpresso Integrated Development Environment (IDE) Install the indvidual tools/systems (arm compiler toolchain, make, openocd, vscode, etc) and configure them accordingly. Note: I once had this project set up to also use Keil MDK (free evaluation version) but the code size of this project now exceeds the 32k limit of Keil. The project files are still in the repo and can probably be updated to work (assuming you have an upgraded Keil without the size limit).","title":"Setting up your development environment"},{"location":"devEnvSetup/#the-easy-way","text":"Installing and using MCUXpresso is by far the simplest solution. It is \"A free-of-charge, code size unlimited, easy-to-use IDE for Kinetis and LPC MCUs, and i.MX RT crossover MCUs\". Visit the NXP website here to download the latest version. Note: You will need to register with NXP in order to download MCUXpresso. MCUXpresso is based on Eclipse with various plugins preinstalled and customized. The repo contains a .project and a .cproject file that MCUXpresso should be able to open. I'll leave it to you to figure out how to use MCUXpresso. With it you should be able to build (compile) the project, flash the firmware (via ST-Link or J-Link), and even debug the code.","title":"The easy way"},{"location":"devEnvSetup/#the-hard-way","text":"The other choice (installing the discrete tools) is a lot more work but something I feel is worth it. By doing so, it sets up your development computer so that you can develop for many more platforms and hardware devices. The tools/systems you'll be installing will consist of: * A code editor (Visual Studio Code is what I'll suggest and describe here) * A compiler toolchain * make as your build system * OpenOCD. A software tool for flashing firmware via ST-Link adapter It should be possible to develop on Mac OS, Linux and Windows platforms. This is due to using a variety of open source tools and technologies that are supported on all of these operating systems. Note: The specific examples provided here will often be written from the perspective of using a Windows development PC. I hope to update this document in the future to provide more specific examples for Mac OS and Linux platforms.","title":"The hard way"},{"location":"devEnvSetup/#developing-with-vscode","text":"I really like Visual Studio Code. It's readily available for Mac OS, Windows and Linux. Plus it's very fast and extensible! I use it not only for editing the code, but also the documentation. And because it has integrated terminal windows I also use it for building and monitoring. It can be an excellent (and lightweight) development envrironment for embedded devices. I've used it with great success when developing for ESP8266, ESP32, Arduino (AVR), STM32, etc. I often use it with Platform IO (but not so with this project). I'll describe how to set up VSCode and associated tools so that we can develop for the (ARM cortex m0+ based) Kinetis KL16 micro used on the FlySky FS-i6 transmitter. Note: Some of what is described here was learned from this (most excellent) article: \"Using Visual Studio Code with STM32CubeMX for ARM Development\" . It's worth the time to read it for yourself.","title":"Developing with VSCode"},{"location":"devEnvSetup/#what-well-need","text":"Here are the list of software tools we'll need for this project. ARM gnu toolchain mingw-w64 (if you will be developing under Windows) This is needed solely for the make tool, or more specifically mingw32-make.exe OpenOCD Visual Studio Code , and the following extensions: Cortex Debug C/C++ for Visual Studio Code Project Manager Note: I've tried using the STM32 ST-LINK utility as well as the open source version from texane but was not able to establish a connection using the ST-Link V2 debugger/programmer I have. Thankfully I was able to get OpenOCD working. You will also need some hardware in order to connect your development PC to your FlySky FS-i6 transmitter. I'm using a (cheapie clone) ST-Link V2 programmer/debugger purchased from Amazon but also readily available on ebay . While working on a previous development project I had installed the \"ST-Link Utility\" from here: https://www.st.com/en/development-tools/stsw-link004.html I'm pretty sure that's how I ended up getting the st-link drivers installed onto my Windows 10 development machine. I also ended up updating the firmware on my ST-Link V2 probe using that utility but I'm not sure if that was necessary. I'm noting it here in case it may be useful. If you don't already have drivers installed for your ST-Link V2 probe, you may be able to use the drivers provided by the OpenOCD installation (described later).","title":"What we'll need"},{"location":"devEnvSetup/#installing-the-tools","text":"If you don't already have VScode installed on your machine please visit: https://code.visualstudio.com/ Follow the install directions. Afterwards we'll need to install some extensions and also configure VSCode slightly. After installing Visual Studio Code, launch it and navigate to Extensions tab or press Ctrl+Shift+X . Install the following extensions: C/C++ \u2013 https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools Cortex Debug \u2013 https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug Project Manager \u2013 https://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager Press F1 key and type open settings json . Select Open Settings (JSON) . In the opened file, insert the following property at the top of the list and save. cortex-debug.armToolchainPath : ${env:VSARM}\\\\armcc\\\\bin\\\\ , For example my settings.json ends up looking like this: { cortex-debug.armToolchainPath : ${env:VSARM}\\\\armcc\\\\bin\\\\ , terminal.integrated.rendererType : dom , terminal.integrated.shell.windows : C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe , platformio-ide.forceUploadAndMonitor : true } Note: The ${env:VSARM} is refrencing an enviornment variable that we'll create shortly For the remaining tools I recommend installing them into into a single folder. On my Windows machine I use C:\\Tools . You could also choose to use C:\\VSARM . Keep it simple and avoid having spaces in the path. On a Mac or Linux machine you could create a subfolder in your home folder. mkdir ~/vsarm Create an environment variable named VSARM and set its value to this folder. For example on my Mac I added this line to my ~/.zshrc file: # VSARM export VSARM= $HOME/vsarm Note: If you use bash (the default shell for Mac OS) then you would instead add that to your ~/.bash_profile file.","title":"Installing the tools"},{"location":"devEnvSetup/#install-arm-gnu-toolchain","text":"Go to: https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads Download the appropriate installer. There are several available.","title":"Install arm gnu toolchain"},{"location":"devEnvSetup/#windows-installation","text":"For my Windows development PC I chose: gcc-arm-none-eabi-8-2019-q3-update-win32-sha2.exe Windows 32-bit Installer (Signed for Windows 7 and later) MD5: d44f44b258b203bdd6808752907754be Run the installer. When it prompts you to \"Choose Install Location\" I changed the default shown in \"Destination Folder\" from: C:\\Program Files (x86)\\GNU Tools ARM Embedded\\8 2019-q3-update to C:\\Tools\\armcc Make sure these gnu tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\armcc\\bin","title":"Windows installation"},{"location":"devEnvSetup/#mac-os-installation","text":"For my old MacBook I chose to download this version: Mac OS X 64-bit File: gcc-arm-none-eabi-8-2019-q3-update-mac.tar.bz2 (105.72 MB) Using a Finder window I then double-clicked on the downloaded .bz2 file which unpacked the contents into a new folder named: gcc-arm-none-eabi-8-2019-q3-update I then renamed that folder to armcc and then moved this armcc folder into my ~/vsarm folder. Finally I adjusted my path by editing my .zshrc file and added this to the bottom of it: # vsarm tools export PATH= $HOME/vsarm/armcc/bin:$PATH Note: If you use bash for your shell (which is the default for Mac OS) then add the above to your ~/.bash_profile instead.","title":"Mac OS installation"},{"location":"devEnvSetup/#install-mingw-w64-for-windows-machines-only","text":"This step is only needed for Windows development machines. We need MinGW-W64 for the mingw32-make.exe program. If you have already have a make utility on your machine then you could skip this Go to: https://sourceforge.net/projects/mingw-w64/ Change the install location to: C:\\Tools\\mingw Make sure the MinGW-W64 tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\mingw\\mingw32\\bin","title":"Install MinGW-W64 (for Windows machines only)"},{"location":"devEnvSetup/#installing-openocd-on-windows","text":"For Windows users I recommend obtaining a version of OpenOCD from here: https://gnutoolchains.com/arm-eabi/openocd/ Download the most recent 7zip file: openocd-20190828.7z Decompress it into C:\\Tools folder. Rename the resultant OpenOCD-20190828-0.10.0 folder to just OpenOCD . Make sure the OpenOCD tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\OpenOCD\\bin Note: There are several binary versions of OpenOCD available for installation. The one from SysProgs (gnutoolchains.com) seems to be updated regularly and also provides drivers that may be helpful to you.","title":"Installing OpenOCD on Windows"},{"location":"devEnvSetup/#installing-openocd-on-mac-os","text":"While it may be possible to install a prebuilt version of OpenOCD using Homebrew, I've learned that the OpenOCD project maintainers recommend Mac/Linux users to build it themselves using the latest version of the source code available from the repository. Note: We will be using the \"Cortex Debug\" extension for VSCode. The README.md file from https://github.com/Marus/cortex-debug mentions not using the default version of OpenOCD provided by Homebrew. So...even more reason for us to build it from source. So to be safe, we'll use Homebrew to build and install OpenOCD using the latest available source code. Using Terminal, enter the following: brew install open-ocd --HEAD This took a little while to complete, but once it finished I found it was immmediately available for use at /usr/local/bin/openocd . No adjustments to my path were needed.","title":"Installing OpenOCD on Mac OS"},{"location":"devEnvSetup/#setup-visual-studio-code-project","text":"This git repo already contains the necessary configurations we need (see the various files in the .vscode folder). Howver I'm going to document how I created these configs so that future adjustments can be performed (such as adding additional source/include folders, etc). Note: For more detailed information about these configs visit: https://code.visualstudio.com/docs/editor/variables-reference https://code.visualstudio.com/docs/cpp/config-msvc https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference","title":"Setup Visual Studio Code Project"},{"location":"devEnvSetup/#configure-ccpp","text":"From within VSCode press F1 key and type edit config and choose C/CPP: Edit Configurations (JSON) . The default contents of this file will look something like this: { configurations : [ { name : Win32 , includePath : [ ${workspaceFolder}/** ], defines : [ _DEBUG , UNICODE , _UNICODE ], windowsSdkVersion : 10.0.17763.0 , compilerPath : C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/VC/Tools/MSVC/14.16.27023/bin/Hostx64/x64/cl.exe , cStandard : c11 , cppStandard : c++17 , intelliSenseMode : msvc-x64 } ], version : 4 } Replace all of this and enter the following: { configurations : [ { name : Debug , includePath : [ ${env:VSARM}/armcc/arm-none-eabi/include/c++/8.3.1 , ${env:VSARM}/armcc/arm-none-eabi/include/c++/8.3.1/arm-none-eabi , ${env:VSARM}/armcc/arm-none-eabi/include/c++/8.3.1/backward , ${env:VSARM}/armcc/lib/gcc/arm-none-eabi/8.3.1/include , ${env:VSARM}/armcc/lib/gcc/arm-none-eabi/8.3.1/include-fixed , ${env:VSARM}/armcc/arm-none-eabi/include , ${workspaceFolder}/** ], defines : [ DEBUG ], intelliSenseMode : clang-x64 , browse : { path : [ ${workspaceFolder} , ${env:VSARM}/armcc ], limitSymbolsToIncludedHeaders : false, databaseFilename : } } ], version : 4 } Be sure to adjust the arm gnu folders such as: ${env:VSARM}/armcc/arm-none-eabi/include/c++/8.3.1 to match the version you actually have installed (hint: the 8.3.1 might need to be changed). For the \"includePath\" property you could replace the \"${workspaceFolder}/**\" wildcard with actual folders (like: \"${workspaceFolder}/include\" ) if you wish. For the \"defines\" property you should add any entries your project may require (examples: \"SOME_VALUE=0x8000\" , \"USE_SOMETHING\" , etc). To create a \"Release\" configuration you could duplicate the above config, change the \"name\" property to \"Release\" , change the \"DEBUG\" define to \"NDEBUG\" , etc.","title":"Configure C/CPP"},{"location":"devEnvSetup/#configure-vscode-tasks","text":"From within VSCode press F1 key and type config task and choose Tasks: Configure tasks . Click on Create tasks.json file from template and select the Other option. The tasks.json file will open. The default contents of this file will look something like this: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format version : 2.0.0 , tasks : [ { label : echo , type : shell , command : echo Hello } ] } Replace the contents of this file with the following: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format version : 2.0.0 , tasks : [ { label : Clean Debug , type : shell , command : make DEBUG=1 clean , windows : { command : mingw32-make.exe DEBUG=1 clean }, options : { cwd : ${workspaceRoot} }, group : build , problemMatcher : [] }, { label : Clean Release , type : shell , command : make DEBUG=0 clean , windows : { command : mingw32-make.exe DEBUG=0 clean }, options : { cwd : ${workspaceRoot} }, group : build , problemMatcher : [] }, { label : Make Debug Firmware , type : shell , command : make -j12 DEBUG=1 , windows : { command : mingw32-make.exe -j12 DEBUG=1 }, options : { cwd : ${workspaceRoot} }, group : build , presentation : { reveal : always , clear : true }, problemMatcher : [] }, { label : Make Release Firmware , type : shell , command : make -j12 DEBUG=0 , windows : { command : mingw32-make.exe -j12 DEBUG=0 }, options : { cwd : ${workspaceRoot} }, group : { kind : build , isDefault : true }, presentation : { reveal : always , clear : true }, problemMatcher : [] }, { label : OpenOCD Flash Debug Firmware , type : shell , command : openocd -f interface/stlink.cfg -f target/klx.cfg -c \\ program fs-i6.elf verify reset exit\\ , options : { cwd : ${workspaceRoot}/gcc_debug }, group : build , problemMatcher : [] }, { label : OpenOCD Flash Release Firmware , type : shell , command : openocd -f interface/stlink.cfg -f target/klx.cfg -c \\ program fs-i6.elf verify reset exit\\ , options : { cwd : ${workspaceRoot}/gcc_release }, group : build , problemMatcher : [] }, { label : JLink Flash Release Firmware , type : shell , windows : { options : { shell : { executable : cmd.exe , args : [ /d , /c ] } }, command : JLink -CommanderScript ../.vscode/load-release.jlink , }, options : { cwd : ${workspaceRoot}/gcc_release , }, group : build , problemMatcher : [] }, { label : JLink Flash Debug Firmware , type : shell , windows : { options : { shell : { executable : cmd.exe , args : [ /d , /c ] } }, command : JLink -CommanderScript ../.vscode/load-release.jlink , }, options : { cwd : ${workspaceRoot}/gcc_debug , }, group : build , problemMatcher : [] } ] } Note: Be sure to adjust the -j parameter to the make if needed. To run any of these tasks you can use Ctrl-Alt-T on Windows, or Ctrl-Option-T on Mac to bring up a menu that allows you to choose any of these tasks we've just defined. Alternatively you can use F1 key and type run task and choose Tasks: Run Task .","title":"Configure VSCode Tasks"},{"location":"devEnvSetup/#configure-vscode-shell","text":"One very important note: The makefile I'm using uses rm -rf as part of building the clean target. This rm command isn't normally available on windows. So I've configured my VSCode environment to use a bash shell whenever it needs to provide a shell for any command. This bash shell came with my Git for Windows installation. If you have something similar, then you'll want to configure VSCode to use such a shell. Alternatively you can edit the makefile(s) in this project folder. To configure VSCode to use a particular shell you need to edit your settings.json file. Details are provided here: https://code.visualstudio.com/docs/editor/integrated-terminal . Basically you need to enter a configuration line like one of the following: // Command Prompt terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\cmd.exe // PowerShell terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe // Git Bash terminal.integrated.shell.windows : C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe // Bash on Ubuntu (on Windows) terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\bash.exe Obviously you should use one of the bash options in the above examples. Personally I prefer the bash from my git install versus the one from my Windows Subsystem for Linux (WSL) since it loads up much faster.","title":"Configure VSCode shell"},{"location":"devEnvSetup/#configure-debugger","text":"From within VSCode use F1 key, type launch and select Debug: Open launch.json and choose the Cortex Debug option. The launch.json file will open with contents that should look something like this: { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 version : 0.2.0 , configurations : [ { name : Cortex Debug , cwd : ${workspaceRoot} , executable : ./bin/executable.elf , request : launch , type : cortex-debug , servertype : jlink } ] } Replace it with this: { version : 0.2.0 , configurations : [ { name : Launch Debug config , type : cortex-debug , request : launch , servertype : openocd , cwd : ${workspaceRoot} , executable : ./Debug/i6.elf , device : Kinetis , svdFile : ${workspaceRoot}/.vscode/MKL16Z4.svd , configFiles : [ interface/stlink.cfg , target/klx.cfg , ] }, { name : Attach Debug config , type : cortex-debug , request : attach , servertype : openocd , cwd : ${workspaceRoot} , executable : ./Debug/i6.elf , device : Kinetis , svdFile : ${workspaceRoot}/.vscode/MKL16Z4.svd , configFiles : [ interface/stlink.cfg , target/klx.cfg , ] } ] } Some useful info about these configs can be found here: https://marcelball.ca/projects/cortex-debug/cortex-debug-launch-configurations/ After these additions have been made you can click on the Debug icon on the left of VSCode and be able to execute one of these configurations. Regarding the .svd file in the above config. A Google search for kinetis svd files led me to this: https://github.com/posborne/cmsis-svd/issues/29 which in turn led me to this: https://github.com/hackrid/KDS_SVD/blob/master/KDS_3_2/MKL16Z4.svd .","title":"Configure Debugger"},{"location":"devEnvSetup/#semihosting","text":"It is possible to direct printf messages ( stdout ) to the debug interface. This capability is known as semihosting . Note: I discovered this via Google and reading about this: https://dzone.com/articles/semihosting-gnu-arm-embedded and also https://bgamari.github.io/posts/2014-10-31-semihosting.html I have not yet attempted using this feature but will investigate this soon.","title":"\"semihosting\""},{"location":"devEnvSetup/#add-shortcuts-extension-to-vscode","text":"The \"Shortcuts\" extension will install clickable icons on the bottom status bar of VSCode. Each icon is a shortcut to a vscode command. Setting this up was tricky. There's no clear documentation that I could find. Press F1 key and type preferences workspace . Select Preferences: Open Workspace Settings . Enter shortcuts in the search bar. Hover your mouse cursor over \"Shortcuts: Buttons\" and a gear icon will appear. Click on the gear icon and choose \"Copy Setting as JSON\" (this will ), then click on \"Edit in settings.json\". Position the cursor between the curly brackets and then paste ( Ctrl+V / Cmd+V ) the copied setting into the file. The file should look like this: shortcuts.buttons : [ file-binary , workbench.action.tasks.build , Run build task , beaker , workbench.action.tasks.test , Run test task , terminal , workbench.action.terminal.toggleTerminal , Toggle terminal panel , telescope , workbench.action.showCommands , Show command palette , bug, workbench.action.debug.start, Launch debug ] This will create 5 new icons on the bottom status bar. I'd prefer to customize these to just 3. So replace the above contents with the following: shortcuts.buttons : [ file-binary , workbench.action.tasks.build , Run Build Task , rocket , workbench.action.tasks.runTask , Run Task , bug, workbench.action.debug.start, Launch Debug ] The first icon (\"file-binary\") should launch the \"Make Debug Firmware\" task (because that is the only one marked as the default build task). The second icon will execute the \"Tasks: Run Task\" command which reveals a dropdown menu of the available tasks. And the third icon will launch a debugging session.","title":"Add \"Shortcuts\" extension to VSCode"}]}